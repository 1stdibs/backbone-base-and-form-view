<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Backbone BaseView and FormView Index</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">
    <link href='//fonts.googleapis.com/css?family=Tenor+Sans' rel='stylesheet' type='text/css'>

	
	<link type="text/css" rel="stylesheet" href="styles/site.dibsy-bootstrap.css">
	
    <link href='http://fonts.googleapis.com/css?family=Tenor+Sans' rel='stylesheet' type='text/css'>
    <style type="text/css">
		  .page-wrapper {
		    margin-top: 60px;
		  }
	      .row-fluid .nav-tabs [class*="span"] {
		    width: 97.87%;
		  }
		  .method {
		  	padding-top: 45px;
		  	margin-top: -30px;
		  }
		  h4 {
		  	border-bottom: 1px solid #ddd;
		  	padding-bottom: 5px
		  }
    </style>

</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top navbar-inverse">
		<div class="navbar-inner">
			<a class="brand" href="index.html">Backbone BaseView and FormView</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="Backbone.BaseView.html">BaseView</a>
						</li>
						
						<li>
							<a href="Backbone.CollectionFieldSetView.html">CollectionFieldSetView</a>
						</li>
						
						<li>
							<a href="Backbone.CollectionFormView.html">CollectionFormView</a>
						</li>
						
						<li>
							<a href="Backbone.fields.CheckBoxView.html">CheckBoxView</a>
						</li>
						
						<li>
							<a href="Backbone.fields.CheckListView.html">CheckListView</a>
						</li>
						
						<li>
							<a href="Backbone.fields.FieldView.html">FieldView</a>
						</li>
						
						<li>
							<a href="Backbone.fields.RadioListView.html">RadioListView</a>
						</li>
						
						<li>
							<a href="Backbone.fields.SelectListView.html">SelectListView</a>
						</li>
						
						<li>
							<a href="Backbone.FieldSetView.html">FieldSetView</a>
						</li>
						
						<li>
							<a href="Backbone.FormView.html">FormView</a>
						</li>
						
						<li>
							<a href="SubViewManager.html">SubViewManager</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid page-wrapper">

		
		<div class="span8">
			
				<div id="main">
					


	
	<a class="page-title" href="https://github.com/1stdibs/backbone-base-and-form-view">View and download the source on Github.</a>
	
	












	
	





    <section>
        <article><h1>Backbone BaseView and FormView</h1>
<h2>TLDR</h2>
<p><strong>Backbone.BaseView</strong> - Organize your views into components (subviews) to decouple them and promote more standard and maintainable code.</p>
<p><strong>Backbone.FormView</strong> - Extends Backbone.BaseView and allows you to define and generate Backbone-ized forms more easily with less code while keeping the decoupled benefits of the BaseView.</p>
<h2>Introduction</h2>
<h3>Backbone.BaseView</h3>
<p>Adds some additional functionality on top of <a href="http://backbonejs.org">Backbone's</a> native View constructor, and most of this is around <em>subview</em> management and managing a hierarchy of views. This can be useful for things like having a view for a collection and then subviews for each model in the collection, but also for a structure where you have nested models and collections within the model you are building a view for. It adds some useful methods in relation to the interaction between parent views and subviews.</p>
<p><strong>Why??</strong> </p>
<p>'Sub-Views' are a concept used often in Backbone without an official way to actually manage them. Backbone is nice enough to let you do pretty much whatever you want, but as a result it doesn't really provide that many structures to help you deal with a more complicated application -- it lets you decide what you want to do. Backbone.BaseView adds the SubViewManager component to standardize a little bit what can often end up being a wild west in terms of what people are doing deal with all the moving pieces inside their views.</p>
<p><strong>Example scenario</strong>: Say you want to make a table view based on a collection and it's models. You can make a TableView, then RowView sub views for it's rows, and then CellView sub views for each column cell in the RowView instance. (See <a href="http://1stdibs.github.io/backbone-base-and-form-view/examples/example-table.html">our basic implementation</a> as an example.)</p>
<p>This allows you to focus only on the functionality of the ColView and it's UI in isolation of the TableView. With Backbone.BaseView, any BaseView can publish events that 'bubble' up or 'descend' down the hierarchy of views, not to mention a set of other functions to help you standardize how your views instantiate each other and communicate with one another.</p>
<p>This means you can write some nice semantic code like this:</p>
<p> <code>tableView.subs.add('row', { model: new RowModel(); });</code></p>
<p><code>tableView.subs.triggerDescend('collapseDetails'); // Triggers an event on all subviews and their subviews</code></p>
<p>This allows you to write views that can be used in many contexts. In a table scenario, you can have a table cell trigger an event that bubbles up to notify the row when an event should affect the entire row, and then the row view can handle this accordingly, without having to write unique logic to </p>
<h3>Backbone.FormView</h3>
<p>Adds functionality on top of <em>Backbone.BaseView</em> to create a framework for generating forms very quickly and standardizing some aspects of this to make augmenting a form is easier for other coders. This is somewhat inspired by <a href="https://github.com/powmedia/backbone-forms">backbone-forms</a> but has a different style and approach to how you can build forms and extend the functionality.</p>
<p><strong>Why??</strong></p>
<p>If you make a lot of Forms with just vanilla Backbone, it's very easy to write a lot of very similar code. You write a template for the form, then write a view that renders the form, then event handlers to take UI form changes and set associated values on the view's model.</p>
<p>Worse, a lot of code could be better standardized but often isn't when people write with vanilla Backbone, not through an issue with Backbone but out of fast development needs superseding organization. A lot of that repetitiveness / unintentional obscurity can be taken away using a Backbone.FormView, not to mention less confusing. A javascript schema object can be used to build the form, and this schema is formatted in a way that is very readable and pretty concise.</p>
<h3>Project Page with 'Class' documentation:</h3>
<p><a href="http://1stdibs.github.io/backbone-base-and-form-view/">Go to the project page</a></p>
<h2>Getting Started</h2>
<h3>Dependencies</h3>
<p><a href="http://jquery.com">jQuery</a></p>
<p><a href="http://underscorejs.org">Underscore</a> OR <a href="http://lodash.com">Lo-Dash</a></p>
<p><a href="http://backbonejs.org">Backbone</a></p>
<h3>Installation</h3>
<p><a href="https://github.com/1stdibs/backbone-base-and-form-view">Download the source code from Github</a></p>
<p><strong>BaseView</strong> - If you just want to use Backbone.BaseView, first load it on your page after Backbone.</p>
<p><strong>FormView</strong> - To use Backbone.FormView, load Backbone.BaseView after Backbone, and then load Backbone.FormView</p>
<h2>Using Backbone.BaseView</h2>
<p>You can use Backbone.BaseView like a normal Backbone.View, however, you get some additional functionality in the form of <em>subviews</em>. A subview is a view that is nested in the '.subViews' array in a BaseView instance, and typically would have it's '.el' HTMLelement inside the BaseViews '.el' HTMLelement. </p>
<p>Backbone.BaseView lets you interact with them through the SubViewManager instance stored in the 'subs' property of the BaseView instance. </p>
<p>A subview should get rendered when the parent BaseView is rendered, but the subview can be rendered without rendering the parent view. Subviews have a proptery '.parentView' that stores a reference to it's parent view.</p>
<h3>Adding a Subview</h3>
<p>To add a subview is through using the SubViewManager's ('.subs') 'add' method. There are several ways you can use this method.</p>
<ul>
<li><p><strong>Adding an instance directly</strong></p>
<pre><code>  var MySubView = Backbone.BaseView.extend();
  var MyView = Backbone.BaseView.extend({
         initialize: function () {
            this.subs.add(new MySubView());
         }
      });
  var testView = new MyView();
  console.log(testView.subViews); // Logs an array with one MySubview instance</code></pre>
</li>
</ul>
<p>This is probably fine if you never need to refer to this sub view by a type. If you provide a string as the first parameter, this serves as a key to refer to the subview by. This would look like <code>this.subs.add('mySubView', new MySubView())</code>. You can continue adding subviews on the same type string (they would be grouped in an array).</p>
<ul>
<li><p><strong>Adding a config first</strong>, and then instantiating from that config. A config tells the SubViewManager some standard information about the subview type.</p>
<pre><code>  var MySubView = Backbone.BaseView.extend();
  var MyView = Backbone.Base.extend({
       initialize: function () {
          var myModel = new Backbone.Model();
          this.subs.addConfig('mySubView', {
               construct: 'MySubView',
               singleton: true,
               location: '.mysub-wrapper'
               options: {
                    // 'default' options to pass to the sub view on init
               }
          });
          this.subs.add('mySubView', {
               model: myModel // Extra options to add on top of the default options
          });
      }
  });</code></pre>
</li>
</ul>
<p>The config above has several properties that are important to know:</p>
<ul>
<li>construct : This tells the SubViewManager what constructor function to use when creating the view </li>
<li>singleton : This tells the SubViewManager that you only want one instance of this type allowed for this SubViewManager. Once it's instantiated, other instances will not be added to that type.</li>
<li>location : When you render the subviews, the SubViewManager makes it easier to place them by allowing you to specify in a config where a subview of this type should be appended to</li>
<li>options : A default set of options to pass to the constructor. When you instantiate this object later with 'add' you can add additional options.</li>
</ul>
<p>With the example above, you could have also added a 'subViewConfig' property to the MyView definition at the top, which in this example would be an object with one key value pair, with the key being 'mySubView' (the name of the sub view type you want to define) and the value being the config object for that type.</p>
<h3>Getting a Sub View</h3>
<p>Now that you have created a subview, you might want to actually use it some point later on, and you need a way to get it. To get a view you can use:</p>
<pre><code>testView.subs.get('mySubView'); // Returns array of MySubView instances</code></pre>
<p>This would return an array, because Backbone.BaseView allows you to add multiple views on a single key. If you want to add a view and ensure that only one of this kind of subview can exist on that key, that's referred to as a <em>singleton</em>. To specify that a view is a singleton when you add it, pass true as the second param like this <code>this.subs.add('mySubView', new MySubView(), true);</code>.</p>
<p>Now that you have a singleton view, you can always get it easily by calling:</p>
<pre><code>var testSubView = testView.subs.get('mySubView'); // Returns instance of MySubView</code></pre>
<p>The '.get' method, will try to find a single instance first using the 'key' provided before returning an array. If the key passed to get doesn't match a singleton, you will get an array of results.</p>
<p><strong>Getting a sub view via a model</strong> - If you pass a model to a subview when it's instantiated as an option, the sub view manager makes it possible to retrieve the view using the model. This could be done as follows:</p>
<pre><code>var testModel = new Backbone.Model();
testView.subs.add('anotherSubView', new MySubView({ 
    model: testModel
}));

testView.subs.get(testModel);
// Returns sub view instance if only one view uses that model, or 
// an array of sub views if you have multiple subviews using that model</code></pre>
<p><strong>Underscore methods to access subViews</strong> - The 'subs' SubViewManager includes curried underscore methods to access or modify subViews. These are: 'each', 'find', 'filter', 'sortBy', 'groupBy', 'where', 'findWhere', 'some', 'every', and 'invoke'. Example usage: <code>this.subs.where({ collection: myCollection }); // Returns array of subview instances</code>.</p>
<h3>Rendering Sub Views</h3>
<ol>
<li><p>You can get the sub view instances and render them individually:</p>
<pre><code> testView.subs.get('mySubView').render();</code></pre>
</li>
<li><p>You can render sub views all at once and append them in their order to a specified selector or element</p>
<pre><code> testView.subs.renderAppend('.subviews-wrapper');</code></pre>
</li>
<li><p>If you specified a location in the subview type's config, then any subviews of that type  will be automatically appended to that location if you use the 'renderAppend' method:</p>
<pre><code>  testView.subs.addConfig('typeB', {
      construct: 'TypeBView',
      location: '.type-b-wrapper'
  });
  testView.subs
      .add('typeB', {
          model: model1
      })
      .add('typeB', {
          model: model2
      })
      .renderAppend(); 
  // the SubViewManager looks in the testView.el element for an element that maches
  // the selector '.type-b-wrapper' and appends the typeB instances to that wrapper</code></pre>
</li>
</ol>
<p><strong>NOTE:</strong> Because renderAppend by sub views are appended to the locations you provide, you may need to clear out the base view's html first. The <code>Backbone.BaseView</code> adds a shortcut 'clear' method to help with this. Additionally, you can pass the 'clearLocations' option to the render methods to clear all locations specified in configurations first: <code>testView.subs.renderAppend({ clearLocations: true });</code>.</p>
<h3>Features</h3>
<p>Okay, well, now that you have this taken care of, a Base View has a few interesting features involving sub view interactions, some of which I will outline here:</p>
<ol>
<li><p>Accessing the subViews parent:</p>
<pre><code> testSubView.parentView; // Instance of MyView</code></pre>
<p><em>Note that you cannot access the '.parentView' property in the initialize method if you instantiate a sub view before it's added to the base view's SubViewManager.</em></p>
</li>
<li><p>Triggering an event that bubbles up to the parent view, and then that parent's parent view, and so on:</p>
<pre><code> testSubView.triggerBubble('myEvent');</code></pre>
</li>
</ol>
<p>Like Backbone.Events.trigger, the first argument passed to triggerBubble should be a string to represent the name of the event. Subsequent arguments are passed to event handler callbacks. The first argument passed to an event handler with triggerBubble (and triggerDescend) will always be the view instance that triggered the event. Custom arguments are the 2nd parameter onward. Listen with the 'on' / 'listenTo' / 'once' and 'listenToOnce' methods, like you would normally do with Backbone.Events objects.</p>
<ol>
<li><p>Triggering an event that descends down through all subViews, and if those subViews also have subViews, it will trigger the event on those as well, and so on:</p>
<pre><code> testView.triggerDescend('myOtherEvent');</code></pre>
<p>Arguments and callbacks work in the same fashion as they do with triggerBubble.</p>
</li>
<li><p>Getting the top view of a sub view heirarchy (i.e. the view that doesn't have a parentView of it's own):</p>
<pre><code> testSubView.getTopView();</code></pre>
</li>
<li><p>Getting an ancestor view that matches a specific type of subview key:</p>
<pre><code> testSubView.getAncestor('typeB');</code></pre>
</li>
<li><p>If you extend the BaseView and define a 'viewEvents' property on the prototype, the BaseView will bind function to events based on the object key. For example:</p>
<pre><code> myView = Backbone.BaseView.extend({
     viewEvents: {
        'change model': 'render',
        'add subs': function () { console.log('a sub view was added!'); }
     }
 });</code></pre>
<p>In the example above, the instance of myView will listen to the model for a 'change' event, and will call render when the event occurs. The key is split on the space where the left side is the event name, and the right side is a Backbone object property on the view. We are also listening to the subs object for the 'add' event and logging to the console when it is fired.  </p>
</li>
<li><p>You can access an array of all subViews attached to a BaseView instance at any time with the '.subViews' property. <em>It is recommended that you do not push directly to this array to avoid issues where you cannot use some functionality of the SubViewManager, use the 'add' method instead</em>.</p>
</li>
</ol>
<h2>BaseView Example - A Table</h2>
<p><a href="http://1stdibs.github.io/backbone-base-and-form-view/examples/example-table.html">Click here for an example</a> for a very <em>very</em> simple table app that uses Backbone.BaseView. Considering that it doesn't do much of anything, the number of Views defined is obviously overkill, but it does illustrate a bunch of concepts that you could use when creating a much more sophisticated app.</p>
<p><strong>For more information on Backbone.BaseView</strong> you can consult the inline documentation in the source code.</p>
<hr>
<h2>Using Backbone.FormView</h2>
<p>Backbone.FormView adds additional functionality by creating standardized fields and allowing you to specify a <em>schema</em>, which is really a subViewConfig with some of the work being done automatically for you. You can define a <em>schema</em> as an option. The schema tells the form view how to assemble the Form when it's rendered.</p>
<pre><code>    var myModel = new Backbone.Model();
    var myForm = new Backbone.FormView({
        model: myModel,
        schema: {
           firstName: {
              type: 'Text',
              options: {
                label: 'First Name',
                templateSrc: $('#my-text-field-template').html();
              }
           }
        }
    });
    $('body').html(myForm.render().el); 
    // Render the form and place it on the page. The form will have a &lt;form&gt; element
    // which contains a field '&lt;div&gt;' wrapper which contains a text &lt;input&gt;</code></pre>
<p>If you do choose to extend the FormView, you can also define schema as a pseudoclass property.</p>
<h3>FormView Schema</h3>
<p>The schema property of the options object has one field defined in the example above, 'firstName'. The schema tells the FormView that the firstName field should be of type 'Text', and that it should be have the label 'First Name'. Each field is actually a sub view, and the FormView basically automatically sorts some things out for you:</p>
<ol>
<li><p>The <em>schema</em> property 'type' is actually an alias of 'construct' (you can use either), and the value 'Text' is an alias of 'Backbone.FormFieldView'. The Backbone.FormView prototype has several built in aliases for field types: 'Text', 'Checkbox', 'Checklist', 'Select', 'Chosen', 'RadioList', 'FieldSet', 'CollectionField'. More on these types will be discussed later.</p>
<p>If you want to use a custom sub view constructor, you can easily just use that as the value of type. For example, if you created a custom field View constructor called 'App.MyField', you can just use that as the type value. <em>Note</em> that if you use a string value as type it will have to be a dot notation object that can be found on the global scope.</p>
</li>
<li><p>The <em>options</em> property is really just some custom options that we want to pass to the 'Text' constructor, just like the options paramater passed to Backbone.View instances. More details on each field are discussed later. This makes it really easy to write a custom field because it is just a Backbone.View (preferably a BaseView but not required) and the options will be what you specify here and what are automatically set by the FormView and passed to the initialize function of the custom View.</p>
</li>
</ol>
<h3>FormView Options</h3>
<p>The FormView constructor allows certain options for each field type so that you don't necessarily need to extend to customize the form the way you want to. These are some of the options you can pass the constructor or set on an extended View's prototype:</p>
<ol>
<li><em>model</em> - <em>Required</em>. Backbone.Model This is the model that the form will set attributes on. The form field sub-views will automatically be passed a reference to this model to their constructor, so that the fields can manage setting the values of their inputs on the appropriate attribute of the model. If the schema key (in the example this is 'firstName') matches a nested model, the sub views will be passed that nested model instead. This is useful if you use a framework like <a href="http://backbonerelational.org/">backbone-relational</a>, <a href="https://github.com/dhruvaray/backbone-associations">backbone-associations</a> or <a href="https://github.com/powmedia/backbone-deep-model">backbone-deep-model</a>.</li>
<li><em>collection</em> - Collections will not be passed to subViews unless the schema defines a collection option for the field. If the value of collection is true, then the sub-view instantiated from the field schema will be passed a the parent view's collection property.</li>
<li><em>templateSrc</em> - String. An underscore template string that can be used with the underscore _.template function. This serves as the shell template that the subviews/fields are appended to. The render function looks for an element with a <em>data-fields</em> attribute and appends the sub-views to that. The FormView default fields have a default template (with <a href="http://getbootstrap.com/">bootstrap</a> classes), which you can use if you want or easily repace with this variable.</li>
<li><em>templateVars</em> - Object. Variables to pass to the template when it is rendered</li>
<li><em>setupOnInit</em> - Boolean. If true, the FormView will create all sub view instances from the schema in the initialize function.</li>
</ol>
<h3>Saving a Form</h3>
<p>Saving a form is simply matter of saving the model. One way this can be achieved is simply using a templateSrc with a submit button, and then attaching an event to that button that saves the model when the user clicks it.</p>
<h3>Basic Fields</h3>
<p>The FormView comes with a set of Field subViews that you can use to create forms without having to define any of your own. They are outlined below:</p>
<h4>Text (alias of Backbone.fields.FieldView)</h4>
<p>Creates a field 'text' type input or textarea, wrapped in a shell template. Sets the associated model attribute with the value of the input/textarea on focusout.</p>
<p>Example schema definition:</p>
<pre><code> description: {
     type: 'Text',
     options : {
         label: 'Item description',
         placeholder: 'Enter the description of your item...',
         elementType: 'textarea'
         templateSrc: $('my-description-template').html()
     }
 }</code></pre>
<p><strong>Options</strong>:</p>
<ol>
<li><em>templateSrc</em> - String. The source for an underscore template to append the input to. If a data-input attribute on the element is specified, then that will directly wrap the input. Otherwise the input will be appeneded directly to the view's '.el' element.</li>
<li><em>label</em> - String. The text you would like to display in the &lt;label&gt; element that is included in part of the template.</li>
<li><em>elementType</em> - String. Should be one of 'input' or 'textarea'.</li>
<li><em>placeholder</em> -  String. The placeholder attribute of the input or textarea element.</li>
<li><em>fieldName</em> - String. The attribute on the model that you want to set on the focus out event. If left out, this field will default to the schema key (in the example this is 'description').</li>
<li><em>inputId</em> - String. The id attribute of the input element you would like to use. This is created automatically from the schema key if it's not provided. It is also used as the name.</li>
<li><em>templateVars</em> - Object. Custom variables you would like to pass to the underscore template function</li>
<li>Input Attrs - Object. If there are other attributes on the input/form element(s) that are not set by the above, then you can specify them with this option.</li>
</ol>
<h4>RadioList (alias of Backbone.fields.RadioListView)</h4>
<p>Like the Text field, except the input is actually just a set of radio buttons. A RadioList field should be associated with a model attribute that expects a single value out of a fixed set of values.</p>
<p>Example schema definition:</p>
<pre><code> gender: {
     type: 'RadioList',
     options : {
         label: 'Gender',
         possibleVals: {
            M: 'Male',
            F: 'Female'
         }
     }
 }</code></pre>
<p><strong>Options</strong>:</p>
<p>Inherited from Text - <em>templateSrc</em>, <em>label</em>, <em>fieldName</em>, <em>inputId</em>, <em>templateVars</em>.</p>
<ol>
<li><em>possibleVals</em> - Object|Array|Function. Should be an object literal or array (or a function that returns one of those) with the choices you would like to have a radio button for. The object keys will be the values that are saved on the model attribute. The values are the display text for each option. If you use an array, the value and the display text will be the values in the array.</li>
</ol>
<h4>Select (alias of Backbone.fields.SelectListView)</h4>
<p>Like the RadioList field, except instead of a set of radio buttons, it's displays a select dropdown. Also has the ability to allow multiple select.</p>
<p>Example schema definition:</p>
<pre><code> country: {
     type: 'Select',
     options : {
         label: 'Country',
         placeholder: 'Select your country...
         possibleVals: {
            USA: 'United States',
            MX: 'Mexico',
            CN: 'Canada'
         }
     }
 }</code></pre>
<p><strong>Options</strong>:</p>
<p>Inherited from Text - <em>templateSrc</em>, <em>label</em>, <em>placeholder</em>, <em>fieldName</em>, <em>inputId</em>, <em>templateVars</em>.</p>
<ol>
<li><p><em>possibleVals</em> - Object|Function. Should be an object literal (or a function that returns one) with the options you would like to have in the select. The keys will be the values that are saved on the model attribute. The values are the display text for each option. Note, the select allows you to create optgroups by nesting possible values as follows:</p>
<pre><code> possibleVals: {
    'Fiction' : {
       ya: 'Young Adult',
       hf: 'Historical Fiction'
    }
    'Non-Fiction: {
       his: 'History',
       sci: 'Scientific'
    }
 }</code></pre>
</li>
</ol>
<h4>CheckList (alias of Backbone.fields.CheckListView)</h4>
<p>Like the RadioList field, except with checkboxes instead of radio buttons. A CheckList field should have an associated field for each checkbox, as each can be either 'on' or 'off'.</p>
<p>Example schema definition:</p>
<pre><code> characteristics: {
     type: 'RadioList',
     options : {
         label: 'Characteristics',
         checkedVal: 'Yes',
         unCheckedVal: 'No',
         possibleVals: {
            fluf: 'Fluffy',
            slk: 'Sleek',
            elg: 'Elegant'
         }
     }
 }</code></pre>
<p><strong>Options</strong>:</p>
<p>Inherited from Text - <em>templateSrc</em>, <em>label</em>, <em>fieldName</em>, <em>inputId</em>, <em>templateVars</em>.</p>
<ol>
<li><em>possibleVals</em> - Object|Function. Should be an object literal with the choices you would like to have a checkbox for. The keys will be the values that are saved on the model attribute. The values are the display text label for each checkbox.</li>
<li><em>checkedVal</em> - Mixed. the value to set on the model when a checkbox is checked for a particular possibleVal. So if the user selected the checkbox with the value 'fluf', and the checkedVal is <code>true</code>, then the 'fluf' attribute on the model will be set to <code>true</code>.</li>
<li><em>unCheckedVal</em> - Mixed. the value to set on the model when a checkbox is unchecked.</li>
</ol>
<h4>CheckBox (alias of Backbone.fields.CheckBoxView)</h4>
<p>Just a simple checkbox in a shell template, associated with an attribute on the model that can have only two values.</p>
<p>Example schema definition:</p>
<pre><code> email: {
     type: 'Checkbox',
     options : {
         displayText: 'Would you like to receive email updates from us?',
         checkedVal: 'Yes',
         unCheckedVal: 'No',
     }
 }</code></pre>
<p><strong>Options</strong>:</p>
<p>Inherited from Text - <em>templateSrc</em>, <em>label</em>, <em>fieldName</em>, <em>inputId</em>, <em>templateVars</em>.</p>
<ol>
<li><em>checkedVal</em> - Mixed. the value set on the model when the users checks the checkbox. In the example above, the 'email' property of the the checkbox would be set to string 'Yes' .</li>
<li><em>unCheckedVal</em> - Mixed. the value to set on the model when a checkbox is unchecked.</li>
<li><em>displayText</em> - String. Helpful text to display on the right of the checkbox. You can also use a label, but labels display on the left side in the default template.</li>
</ol>
<h2>Backbone.CollectionFormView</h2>
<p>A variant of Backbone.FormView that works in a very similar manner, except that instead of rendering one subView for each field defined in the schema, a 'row' or 'fieldset' will be rendered for each model in the collection passed to the Backbone.CollectionFormView. </p>
<p>Effectively, this renders a modified FormView for each model in the collection, and adds some methods to make it easier to modify the collection form like 'addRow', 'deleteRow', and 'reset'.</p>
<p>What this means is that each field in schema will have a subview created for each model in the collection, and will be grouped into by a wrapper element that possesses a 'data-row' attribute.</p>
<h2>Example FormView Demos</h2>
<p>All of these form's are pretty bare-bones -- just to illustrate the concepts in a simple manner.</p>
<ul>
<li><p><a href="http://1stdibs.github.io/backbone-base-and-form-view/examples/example-simple-form.html">Example simple form</a></p>
</li>
<li><p><a href="http://1stdibs.github.io/backbone-base-and-form-view/examples/example-collection-form.html">Example collection form</a></p>
</li>
<li><p><a href="http://1stdibs.github.io/backbone-base-and-form-view/examples/example-advanced-form.html">Example advanced form</a></p>
</li>
<li><p><a href="http://1stdibs.github.io/backbone-base-and-form-view/examples/example-todo-formview.html">Example Todo App (FormView Version)</a></p>
</li>
</ul></article>
    </section>







				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="copyright">
		Backbone.BaseView and Backbone.FormView Copyright © 2013 The contributors to the JSDoc3 and DocStrap projects.
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a>
		using a custom fork of the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<div class="span3">
				<div id="toc"></div>
			</div>
			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<!-- // <script src="scripts/sunlight-plugin.linenumbers.js"></script> -->
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc({
				selectors   : "h1,h3,h4:not(.class) .name",
				showAndHide : false,
				scrollTo    : 60
			}).children().css({ overflowY:'auto', height: '80%', width: '31%' });
			$( "#toc>ul" ).addClass( "nav nav-tabs affix nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );
		} );
	</script>

	

</body>
</html>